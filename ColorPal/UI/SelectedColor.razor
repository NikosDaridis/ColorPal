@implements IDisposable

<div class="relative flex h-[125px] w-full cursor-pointer flex-col items-center justify-center text-black"
     style="background-color: @(_selectedHEXColor)"
     @onclick=OpenColorPickerAsync>
    <div class="absolute left-4 right-4 top-2 flex items-center justify-between">
        <RoundButton IconPath="Icons\eyedropper.svg"
                     IconThemeFilter=false
                     HandleClick=HandleEyeDropperClickAsync />
        @if (_colorName.Show && !string.IsNullOrWhiteSpace(_colorName.Selected.Name) && JSRuntime is not null)
        {
            <p class="cursor-pointer rounded-lg bg-white bg-opacity-50 px-2 py-1 text-center text-xs font-semibold shadow-xl backdrop-blur-xl transition-all duration-200 hover:scale-105 hover:bg-opacity-75"
               @onclick=@(async() => await JSRuntime.InvokeVoidAsync("copyToClipboard", _colorName.Selected.Name))
            @onclick:stopPropagation>
                @_colorName.Selected.Name
            </p>
        }

        <RoundButton IconPath="Icons\settings.svg"
                     IconThemeFilter=false
                     HandleClick=@(() => NavigationManager?.NavigateTo("/settings")) />
    </div>
    @if (!_isSelectedColorSaved)
    {
        <div class="absolute bottom-2">
            <RoundButton IconPath="Icons\plus.svg"
                         IconThemeFilter=false
                         HandleClick=@(async () => await SaveColorAsync(_selectedHEXColor)) />
        </div>
    }
</div>
<input class="b-0 absolute left-[34px] top-[216px] m-0 h-0 w-0 p-0 opacity-0"
       type="color"
       id="colorPicker"
       value=@_selectedHEXColor
       @oninput=HandleColorPickerInput>

@code {
    [Parameter]
    public NavigationManager? NavigationManager { get; set; }

    [Parameter]
    public IJSRuntime? JSRuntime { get; set; }

    [Parameter]
    public LocalStorageService? LocalStorageService { get; set; }

    [Parameter]
    public EventAggregator<string>? EventAggregator { get; set; }

    [Parameter]
    public StateService? StateService { get; set; }

    private string _selectedHEXColor = "#000000";
    private bool _isSelectedColorSaved;
    private (bool Show, ColorName Selected, List<ColorName> All) _colorName = (true, new(), []);
    private Timer? _colorPickerDebounceTimer;

    protected override async Task OnInitializedAsync()
    {
        await base.OnInitializedAsync();

        if (JSRuntime is null || LocalStorageService is null || EventAggregator is null || StateService is null)
            return;

        EventAggregator.GetService(Event.EyedropperPick).Subscribe(SetSelectedColorAsync);
        EventAggregator.GetService(Event.EyedropperPick).Subscribe(SaveEyedropperColorAsync);

        _selectedHEXColor = await LocalStorageService.GetKeyAsync<string>(StorageKey.SelectedColor) ?? "#000000";
        _isSelectedColorSaved = (await IsColorSavedAsync(_selectedHEXColor)).IsSaved;
        _colorName.Show = await LocalStorageService.GetKeyAsync<string>(StorageKey.ShowColorNames) == "true";

        _ = Task.Run(async () =>
        {
            while (!_colorName.All.Any())
            {
                _colorName.All = StateService.GetColorNames();
                await Task.Delay(50);

                if (!_colorName.All.Any())
                    continue;

                _colorName.Selected = StateService.FindClosestNamedColor(await JSRuntime.InvokeAsync<ColorRGB>("hexToRgb", _selectedHEXColor)) ?? new();
                StateHasChanged();
            }
        });
    }

    private async Task HandleEyeDropperClickAsync()
    {
        if (JSRuntime is null)
            return;

        string eyeDropperColor = await JSRuntime.InvokeAsync<string?>("activateEyeDropper") ?? string.Empty;

        EventAggregator?.GetService(Event.EyedropperPick).PublishAsync(eyeDropperColor);
    }

    private async Task SetSelectedColorAsync(string hexColor)
    {
        if (string.IsNullOrWhiteSpace(hexColor) || JSRuntime is null || LocalStorageService is null || EventAggregator is null || StateService is null)
            return;

        _selectedHEXColor = hexColor;
        (bool isSaved, string[] savedColors) = await IsColorSavedAsync(_selectedHEXColor);
        _isSelectedColorSaved = isSaved;

        if (_colorName.Show)
            _colorName.Selected = StateService.FindClosestNamedColor(await JSRuntime.InvokeAsync<ColorRGB>("hexToRgb", _selectedHEXColor)) ?? new();

        await LocalStorageService.SetKeyAsync(StorageKey.SelectedColor, hexColor);

        await EventAggregator.GetService(Event.SetSelectedColor).PublishAsync(_selectedHEXColor);

        await InvokeAsync(StateHasChanged);
    }

    private async Task<(bool IsSaved, string[] SavedColors)> IsColorSavedAsync(string color)
    {
        if (LocalStorageService is null)
            return (false, []);

        string[] savedColors = await LocalStorageService.GetKeyAsync<string[]>(StorageKey.SavedColorsArray) ?? [];
        return (savedColors.Contains(color), savedColors);
    }

    private async Task SaveEyedropperColorAsync(string color) =>
        await SaveColorAsync(color, true);

    private async Task SaveColorAsync(string color, bool checkSettings = false)
    {
        if (LocalStorageService is null || EventAggregator is null)
            return;

        (bool isSaved, string[] savedColors) = await IsColorSavedAsync(_selectedHEXColor);
        _isSelectedColorSaved = isSaved;

        if (checkSettings && await LocalStorageService.GetKeyAsync<string>(StorageKey.AutoSaveEyedropper) != "true")
            return;

        await CopyColorCodeToClipboardAsync(_selectedHEXColor);

        if (savedColors.Contains(color))
            return;

        Array.Resize(ref savedColors, savedColors.Length + 1);
        savedColors[^1] = color;
        _isSelectedColorSaved = true;
        await LocalStorageService.SetKeyAsync(StorageKey.SavedColorsArray, savedColors);
        await EventAggregator.GetService(Event.SaveColor).PublishAsync(color);
    }

    private async Task OpenColorPickerAsync()
    {
        if (JSRuntime is null)
            return;

        await JSRuntime.InvokeVoidAsync("openColorPicker", "colorPicker");
    }

    private void HandleColorPickerInput(ChangeEventArgs e)
    {
        if (e.Value is not string color || string.IsNullOrWhiteSpace(color))
            return;

        _colorPickerDebounceTimer?.Dispose();

        _colorPickerDebounceTimer = new Timer(async _ =>
       {
           await InvokeAsync(async () => await SetSelectedColorAsync(color));
       }, null, 5, Timeout.Infinite);
    }

    private async Task CopyColorCodeToClipboardAsync(string hexColor)
    {
        if (JSRuntime is null || LocalStorageService is null)
            return;

        if (await LocalStorageService.GetKeyAsync<string>(StorageKey.AutoCopyCode) != "true")
            return;

        ColorCodeFormat activeColorCodeFormat = Enum.Parse<ColorCodeFormat>(await LocalStorageService.GetKeyAsync<string>(StorageKey.ColorCodeFormat) ?? ColorCodeFormat.HEX.GetValue());
        CssFilter filter = new();

        if (activeColorCodeFormat == ColorCodeFormat.Filter)
        {
            filter = await JSRuntime.InvokeAsync<CssFilter>("hexToFilter", hexColor);

            if (await LocalStorageService.GetKeyAsync<string>(StorageKey.PrependBlackFilter) == "true")
                filter.Filter = filter.Filter?.Replace("filter:", "filter: brightness(0) saturate(100%) ");
        }

        string colorCode = activeColorCodeFormat switch
        {
            ColorCodeFormat.HEX => hexColor,
            ColorCodeFormat.RGB => await JSRuntime.InvokeAsync<string>("hexToRgb", hexColor, "string"),
            ColorCodeFormat.HSL => await JSRuntime.InvokeAsync<string>("hexToHsl", hexColor, "string"),
            ColorCodeFormat.HSV => await JSRuntime.InvokeAsync<string>("hexToHsv", hexColor, "string"),
            ColorCodeFormat.Filter => filter.Filter ?? hexColor,
            _ => hexColor
        };

        await JSRuntime.InvokeVoidAsync("copyToClipboard", colorCode);
    }

    public void Dispose()
    {
        if (EventAggregator is null)
            return;

        EventAggregator.GetService(Event.EyedropperPick).Unsubscribe(SetSelectedColorAsync);
        EventAggregator.GetService(Event.EyedropperPick).Unsubscribe(SaveEyedropperColorAsync);
    }
}
